local a={}local b={}local c={}local d={}local e={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258}local f={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0}local g={[0]=1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577}local h={[0]=0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13}local i={16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15}local j;local k;local l;local m;local n;local o;local p;local q;for r=0,255 do c[r]=string.char(r)end;do local s=1;for r=0,32 do b[r]=s;s=s*2 end end;for r=1,9 do d[r]={}for t=0,b[r+1]-1 do local u=0;local v=t;for w=1,r do u=u-u%2+((u%2==1 or v%2==1)and 1 or 0)v=(v-v%2)/2;u=u*2 end;d[r][t]=(u-u%2)/2 end end;function a:Adler32(x)if type(x)~="string"then error(("Usage: LibDeflate:Adler32(str):".." 'str' - string expected got '%s'."):format(type(x)),2)end;local y=#x;local r=1;local z=1;local A=0;while r<=y-15 do local B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q=string.byte(x,r,r+15)A=(A+16*z+16*B+15*C+14*D+13*E+12*F+11*G+10*H+9*I+8*J+7*K+6*L+5*M+4*N+3*O+2*P+Q)%65521;z=(z+B+C+D+E+F+G+H+I+J+K+L+M+N+O+P+Q)%65521;r=r+16 end;while r<=y do local R=string.byte(x,r,r)z=(z+R)%65521;A=(A+z)%65521;r=r+1 end;return(A*65536+z)%4294967296 end;local function S(T,U)return T%4294967296==U%4294967296 end;function a:CreateDictionary(x,y,V)if type(x)~="string"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - string expected got '%s'."):format(type(x)),2)end;if type(y)~="number"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'strlen' - number expected got '%s'."):format(type(y)),2)end;if type(V)~="number"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'adler32' - number expected got '%s'."):format(type(V)),2)end;if y~=#x then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'strlen' does not match the actual length of 'str'.".." 'strlen': %u, '#str': %u .".." Please check if 'str' is modified unintentionally."):format(y,#x))end;if y==0 then error("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - Empty string is not allowed.",2)end;if y>32768 then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - string longer than 32768 bytes is not allowed.".." Got %d bytes."):format(y),2)end;local W=self:Adler32(x)if not S(V,W)then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'adler32' does not match the actual adler32 of 'str'.".." 'adler32': %u, 'Adler32(str)': %u .".." Please check if 'str' is modified unintentionally."):format(V,W))end;local X={}X.adler32=V;X.hash_tables={}X.string_table={}X.strlen=y;local Y=X.string_table;local Z=X.hash_tables;Y[1]=string.byte(x,1,1)Y[2]=string.byte(x,2,2)if y>=3 then local r=1;local _=Y[1]*256+Y[2]while r<=y-2-3 do local B,C,D,E=string.byte(x,r+2,r+5)Y[r+2]=B;Y[r+3]=C;Y[r+4]=D;Y[r+5]=E;_=(_*256+B)%16777216;local a0=Z[_]if not a0 then a0={}Z[_]=a0 end;a0[#a0+1]=r-y;r=r+1;_=(_*256+C)%16777216;a0=Z[_]if not a0 then a0={}Z[_]=a0 end;a0[#a0+1]=r-y;r=r+1;_=(_*256+D)%16777216;a0=Z[_]if not a0 then a0={}Z[_]=a0 end;a0[#a0+1]=r-y;r=r+1;_=(_*256+E)%16777216;a0=Z[_]if not a0 then a0={}Z[_]=a0 end;a0[#a0+1]=r-y;r=r+1 end;while r<=y-2 do local R=string.byte(x,r+2)Y[r+2]=R;_=(_*256+R)%16777216;local a0=Z[_]if not a0 then a0={}Z[_]=a0 end;a0[#a0+1]=r-y;r=r+1 end end;return X end;local function a1(X)if type(X)~="table"then return false,("'dictionary' - table expected got '%s'."):format(type(X))end;if type(X.adler32)~="number"or type(X.string_table)~="table"or type(X.strlen)~="number"or X.strlen<=0 or X.strlen>32768 or X.strlen~=#X.string_table or type(X.hash_tables)~="table"then return false,("'dictionary' - corrupted dictionary."):format(type(X))end;return true,""end;local a2={[0]={false,nil,0,0,0},[1]={false,nil,4,8,4},[2]={false,nil,5,18,8},[3]={false,nil,6,32,32},[4]={true,4,4,16,16},[5]={true,8,16,32,32},[6]={true,8,16,128,128},[7]={true,8,32,128,256},[8]={true,32,128,258,1024},[9]={true,32,258,258,4096}}local function a3(x,a4,X,a5,a6)if type(x)~="string"then return false,("'str' - string expected got '%s'."):format(type(x))end;if a4 then local a7,a8=a1(X)if not a7 then return false,a8 end end;if a5 then local a9=type(a6)if a9~="nil"and a9~="table"then return false,("'configs' - nil or table expected got '%s'."):format(type(a6))end;if a9=="table"then for aa,ab in pairs(a6)do if aa~="level"and aa~="strategy"then return false,("'configs' - unsupported table key in the configs: '%s'."):format(aa)elseif aa=="level"and not a2[ab]then return false,("'configs' - unsupported 'level': %s."):format(tostring(ab))elseif aa=="strategy"and ab~="fixed"and ab~="huffman_only"and ab~="dynamic"then return false,("'configs' - unsupported 'strategy': '%s'."):format(tostring(ab))end end end end;return true,""end;local function ac(ad,ae,af,ag)local ah=0;local ai={}local aj={}for ak=1,ag do ah=(ah+(ad[ak-1]or 0))*2;ai[ak]=ah end;for al=0,af do local ak=ae[al]if ak then ah=ai[ak]ai[ak]=ah+1;if ak<=9 then aj[al]=d[ak][ah]else local u=0;for w=1,ak do u=u-u%2+((u%2==1 or ah%2==1)and 1 or 0)ah=(ah-ah%2)/2;u=u*2 end;aj[al]=(u-u%2)/2 end end end;return aj end;local function am(an)local ao=an;local ap=#an;local aq=1;local ar=0;local as=0;local function at(ak)local au=b[ak]local av;if ak<=ar then av=as%au;as=(as-av)/au;ar=ar-ak else local aw=b[ar]local ax,ay,az,aA=string.byte(ao,aq,aq+3)as=as+((ax or 0)+(ay or 0)*256+(az or 0)*65536+(aA or 0)*16777216)*aw;aq=aq+4;ar=ar+32-ak;av=as%au;as=(as-av)/au end;return av end;local function aB(aC,aD,aE)assert(ar%8==0,'')local aF=ar/8<aC and ar/8 or aC;for w=1,aF do local aG=as%256;aE=aE+1;aD[aE]=string.char(aG)as=(as-aG)/256 end;ar=ar-aF*8;aC=aC-aF;if(ap-aq-aC+1)*8+ar<0 then return-1 end;for r=aq,aq+aC-1 do aE=aE+1;aD[aE]=string.sub(ao,r,r)end;aq=aq+aC;return aE end;local function aH(aI,aJ,aK)local av=0;local aL=0;local aM=0;local aN;if aK>0 then if ar<15 and ao then local aw=b[ar]local ax,ay,az,aA=string.byte(ao,aq,aq+3)as=as+((ax or 0)+(ay or 0)*256+(az or 0)*65536+(aA or 0)*16777216)*aw;aq=aq+4;ar=ar+32 end;local au=b[aK]ar=ar-aK;av=as%au;as=(as-av)/au;av=d[aK][av]aN=aI[aK]if av<aN then return aJ[av]end;aM=aN;aL=aN*2;av=av*2 end;for ak=aK+1,15 do local aO;aO=as%2;as=(as-aO)/2;ar=ar-1;av=aO==1 and av+1-av%2 or av;aN=aI[ak]or 0;local aP=av-aL;if aP<aN then return aJ[aM+aP]end;aM=aM+aN;aL=aL+aN;aL=aL*2;av=av*2 end;return-10 end;local function aQ()return(ap-aq+1)*8+ar end;local function aR()local aS=ar%8;local au=b[aS]ar=ar-aS;as=(as-as%au)/au end;return at,aB,aH,aQ,aR end;local function aT(x,X)local at,aB,aH,aQ,aR=am(x)return{ReadBits=at,ReadBytes=aB,Decode=aH,ReaderBitlenLeft=aQ,SkipToByteBoundary=aR,buffer_size=0,buffer={},result_buffer={},dictionary=X}end;local function aU(aV,af,ag)local aI={}local aK=ag;for al=0,af do local ak=aV[al]or 0;aK=ak>0 and ak<aK and ak or aK;aI[ak]=(aI[ak]or 0)+1 end;if aI[0]==af+1 then return 0,aI,{},0 end;local aW=1;for aX=1,ag do aW=aW*2;aW=aW-(aI[aX]or 0)if aW<0 then return aW end end;local aY={}aY[1]=0;for aX=1,ag-1 do aY[aX+1]=aY[aX]+(aI[aX]or 0)end;local aJ={}for al=0,af do local ak=aV[al]or 0;if ak~=0 then local aZ=aY[ak]aJ[aZ]=al;aY[ak]=aY[ak]+1 end end;return aW,aI,aJ,aK end;local function a_(b0,b1,b2,b3,b4,b5,b6)local aD,aE,at,aH,aQ,b7=b0.buffer,b0.buffer_size,b0.ReadBits,b0.Decode,b0.ReaderBitlenLeft,b0.result_buffer;local X=b0.dictionary;local b8;local b9;local ba=1;if X and not aD[0]then b8=X.string_table;b9=X.strlen;ba=-b9+1;for r=0,-b9+1<-257 and-257 or-b9+1,-1 do aD[r]=c[b8[b9+r]]end end;repeat local al=aH(b1,b2,b3)if al<0 or al>285 then return-10 elseif al<256 then aE=aE+1;aD[aE]=c[al]elseif al>256 then al=al-256;local ak=e[al]ak=al>=8 and ak+at(f[al])or ak;al=aH(b4,b5,b6)if al<0 or al>29 then return-10 end;local bb=g[al]bb=bb>4 and bb+at(h[al])or bb;local bc=aE-bb+1;if bc<ba then return-11 end;if bc>=-257 then for w=1,ak do aE=aE+1;aD[aE]=aD[bc]bc=bc+1 end else bc=b9+bc;for w=1,ak do aE=aE+1;aD[aE]=c[b8[bc]]bc=bc+1 end end end;if aQ()<0 then return 2 end;if aE>=65536 then b7[#b7+1]=table.concat(aD,"",1,32768)for r=32769,aE do aD[r-32768]=aD[r]end;aE=aE-32768;aD[aE+1]=nil end until al==256;b0.buffer_size=aE;return 0 end;local function bd(b0)local aD,aE,at,aB,aQ,aR,b7=b0.buffer,b0.buffer_size,b0.ReadBits,b0.ReadBytes,b0.ReaderBitlenLeft,b0.SkipToByteBoundary,b0.result_buffer;aR()local aC=at(16)if aQ()<0 then return 2 end;local be=at(16)if aQ()<0 then return 2 end;if aC%256+be%256~=255 then return-2 end;if(aC-aC%256)/256+(be-be%256)/256~=255 then return-2 end;aE=aB(aC,aD,aE)if aE<0 then return 2 end;if aE>=65536 then b7[#b7+1]=table.concat(aD,"",1,32768)for r=32769,aE do aD[r-32768]=aD[r]end;aE=aE-32768;aD[aE+1]=nil end;b0.buffer_size=aE;return 0 end;local function bf(b0)return a_(b0,m,k,7,q,o,5)end;local function bg(b0)local at,aH=b0.ReadBits,b0.Decode;local bh=at(5)+257;local bi=at(5)+1;local bj=at(4)+4;if bh>286 or bi>30 then return-3 end;local bk={}for r=1,bj do bk[i[r]]=at(3)end;local bl,bm,bn,bo=aU(bk,18,7)if bl~=0 then return-4 end;local b1={}local b4={}local aM=0;while aM<bh+bi do local al;local ak;al=aH(bm,bn,bo)if al<0 then return al elseif al<16 then if aM<bh then b1[aM]=al else b4[aM-bh]=al end;aM=aM+1 else ak=0;if al==16 then if aM==0 then return-5 end;if aM-1<bh then ak=b1[aM-1]else ak=b4[aM-bh-1]end;al=3+at(2)elseif al==17 then al=3+at(3)else al=11+at(7)end;if aM+al>bh+bi then return-6 end;while al>0 do al=al-1;if aM<bh then b1[aM]=ak else b4[aM-bh]=ak end;aM=aM+1 end end end;if(b1[256]or 0)==0 then return-9 end;local bp,bq,b2,b3=aU(b1,bh-1,15)if bp~=0 and(bp<0 or bh~=(bq[0]or 0)+(bq[1]or 0))then return-7 end;local br,bs,b5,b6=aU(b4,bi-1,15)if br~=0 and(br<0 or bi~=(bs[0]or 0)+(bs[1]or 0))then return-8 end;return a_(b0,bq,b2,b3,bs,b5,b6)end;local function bt(b0)local at=b0.ReadBits;local bu;while not bu do bu=at(1)==1;local bv=at(2)local bw;if bv==0 then bw=bd(b0)elseif bv==1 then bw=bf(b0)elseif bv==2 then bw=bg(b0)else return nil,-1 end;if bw~=0 then return nil,bw end end;b0.result_buffer[#b0.result_buffer+1]=table.concat(b0.buffer,"",1,b0.buffer_size)local bx=table.concat(b0.result_buffer)return bx end;local function by(x,X)local b0=aT(x,X)local at=b0.ReadBits;local bz=at(8)if b0.ReaderBitlenLeft()<0 then return nil,2 end;local bA=bz%16;local bB=(bz-bA)/16;if bA~=8 then return nil,-12 end;if bB>7 then return nil,-13 end;local bC=at(8)if b0.ReaderBitlenLeft()<0 then return nil,2 end;if(bz*256+bC)%31~=0 then return nil,-14 end;local bD=(bC-bC%32)/32%2;if bD==1 then if not X then return nil,-16 end;local az=at(8)local ay=at(8)local ax=at(8)local bE=at(8)local W=az*16777216+ay*65536+ax*256+bE;if b0.ReaderBitlenLeft()<0 then return nil,2 end;if not S(W,X.adler32)then return nil,-17 end end;local bx,bw=bt(b0)if not bx then return nil,bw end;b0.SkipToByteBoundary()local bF=at(8)local bG=at(8)local bH=at(8)local bI=at(8)if b0.ReaderBitlenLeft()<0 then return nil,2 end;local bJ=bF*16777216+bG*65536+bH*256+bI;local bK=a:Adler32(bx)if not S(bJ,bK)then return nil,-15 end;local bL=b0.ReaderBitlenLeft()local bM=(bL-bL%8)/8;return bx,bM end;function a:DecompressZlib(x)local bN,bO=a3(x)if not bN then error("Usage: LibDeflate:DecompressZlib(str): "..bO,2)end;return by(x)end;function a:DecompressZlibWithDict(x,X)local bN,bO=a3(x,true,X)if not bN then error("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "..bO,2)end;return by(x,X)end;do l={}for bP=0,143 do l[bP]=8 end;for bP=144,255 do l[bP]=9 end;for bP=256,279 do l[bP]=7 end;for bP=280,287 do l[bP]=8 end;p={}for bb=0,31 do p[bb]=5 end;local bw;bw,m,k=aU(l,287,9)assert(bw==0,'')bw,q,o=aU(p,31,5)assert(bw==0,'')j=ac(m,l,287,9)n=ac(q,p,31,5)end;local bQ={["\000"]="%z",["("]="%(",[")"]="%)",["."]="%.",["%"]="%%",["+"]="%+",["-"]="%-",["*"]="%*",["?"]="%?",["["]="%[",["]"]="%]",["^"]="%^",["$"]="%$"}local function bR(x)return x:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])",bQ)end;function a:CreateCodec(bS,bT,bU)if type(bS)~="string"or type(bT)~="string"or type(bU)~="string"then error("Usage: LibDeflate:CreateCodec(reserved_chars,".." escape_chars, map_chars):".." All arguments must be string.",2)end;if bT==""then return nil,"No escape characters supplied."end;if#bS<#bU then return nil,"The number of reserved characters must be".." at least as many as the number of mapped chars."end;if bS==""then return nil,"No characters to encode."end;local bV=bS..bT..bU;local bW={}for r=1,#bV do local aG=string.byte(bV,r,r)if bW[aG]then return nil,"There must be no duplicate characters in the".." concatenation of reserved_chars, escape_chars and".." map_chars."end;bW[aG]=true end;local bX={}local bY={}local bZ={}local b_={}if#bU>0 then local c0={}local c1={}for r=1,#bU do local c2=string.sub(bS,r,r)local c3=string.sub(bU,r,r)b_[c2]=c3;bZ[#bZ+1]=c2;c1[c3]=c2;c0[#c0+1]=c3 end;bX[#bX+1]="(["..bR(table.concat(c0)).."])"bY[#bY+1]=c1 end;local c4=1;local c5=string.sub(bT,c4,c4)local c6=0;local c0={}local c1={}for r=1,#bV do local c7=string.sub(bV,r,r)if not b_[c7]then while c6>=256 or bW[c6]do c6=c6+1;if c6>255 then bX[#bX+1]=bR(c5).."(["..bR(table.concat(c0)).."])"bY[#bY+1]=c1;c4=c4+1;c5=string.sub(bT,c4,c4)c6=0;c0={}c1={}if not c5 or c5==""then return nil,"Out of escape characters."end end end;local c8=c[c6]b_[c7]=c5 ..c8;bZ[#bZ+1]=c7;c1[c8]=c7;c0[#c0+1]=c8;c6=c6+1 end;if r==#bV then bX[#bX+1]=bR(c5).."(["..bR(table.concat(c0)).."])"bY[#bY+1]=c1 end end;local c9={}local ca="(["..bR(table.concat(bZ)).."])"local cb=b_;function c9:Encode(x)if type(x)~="string"then error(("Usage: codec:Encode(str):".." 'str' - string expected got '%s'."):format(type(x)),2)end;return string.gsub(x,ca,cb)end;local cc=#bX;local cd="(["..bR(bS).."])"function c9:Decode(x)if type(x)~="string"then error(("Usage: codec:Decode(str):".." 'str' - string expected got '%s'."):format(type(x)),2)end;if string.find(x,cd)then return nil end;for r=1,cc do x=string.gsub(x,bX[r],bY[r])end;return x end;return c9 end;local ce={[0]="a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9","(",")"}local cf={[97]=0,[98]=1,[99]=2,[100]=3,[101]=4,[102]=5,[103]=6,[104]=7,[105]=8,[106]=9,[107]=10,[108]=11,[109]=12,[110]=13,[111]=14,[112]=15,[113]=16,[114]=17,[115]=18,[116]=19,[117]=20,[118]=21,[119]=22,[120]=23,[121]=24,[122]=25,[65]=26,[66]=27,[67]=28,[68]=29,[69]=30,[70]=31,[71]=32,[72]=33,[73]=34,[74]=35,[75]=36,[76]=37,[77]=38,[78]=39,[79]=40,[80]=41,[81]=42,[82]=43,[83]=44,[84]=45,[85]=46,[86]=47,[87]=48,[88]=49,[89]=50,[90]=51,[48]=52,[49]=53,[50]=54,[51]=55,[52]=56,[53]=57,[54]=58,[55]=59,[56]=60,[57]=61,[40]=62,[41]=63}function a:EncodeForPrint(x)if type(x)~="string"then error(("Usage: LibDeflate:EncodeForPrint(str):".." 'str' - string expected got '%s'."):format(type(x)),2)end;local y=#x;local cg=y-2;local r=1;local aD={}local aE=0;while r<=cg do local B,C,D=string.byte(x,r,r+2)r=r+3;local as=B+C*256+D*65536;local ch=as%64;as=(as-ch)/64;local ci=as%64;as=(as-ci)/64;local cj=as%64;local ck=(as-cj)/64;aE=aE+1;aD[aE]=ce[ch]..ce[ci]..ce[cj]..ce[ck]end;local as=0;local ar=0;while r<=y do local R=string.byte(x,r,r)as=as+R*b[ar]ar=ar+8;r=r+1 end;while ar>0 do local cl=as%64;aE=aE+1;aD[aE]=ce[cl]as=(as-cl)/64;ar=ar-6 end;return table.concat(aD)end;function a:DecodeForPrint(x)if type(x)~="string"then error(("Usage: LibDeflate:DecodeForPrint(str):".." 'str' - string expected got '%s'."):format(type(x)),2)end;x=x:gsub("^[%c ]+","")x=x:gsub("[%c ]+$","")local y=#x;if y==1 then return nil end;local cm=y-3;local r=1;local aD={}local aE=0;while r<=cm do local B,C,D,E=string.byte(x,r,r+3)B=cf[B]C=cf[C]D=cf[D]E=cf[E]if not(B and C and D and E)then return nil end;r=r+4;local as=B+C*64+D*4096+E*262144;local ch=as%256;as=(as-ch)/256;local ci=as%256;local cj=(as-ci)/256;aE=aE+1;aD[aE]=c[ch]..c[ci]..c[cj]end;local as=0;local ar=0;while r<=y do local R=string.byte(x,r,r)R=cf[R]if not R then return nil end;as=as+R*b[ar]ar=ar+6;r=r+1 end;while ar>=8 do local aG=as%256;aE=aE+1;aD[aE]=c[aG]as=(as-aG)/256;ar=ar-8 end;return table.concat(aD)end;function _G.ZLibDecompress(cn)return a:DecompressZlib(cn)end